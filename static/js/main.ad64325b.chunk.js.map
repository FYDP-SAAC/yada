{"version":3,"sources":["actions/index.js","lib/TagFilters.js","reducers/SetTagFilters.js","reducers/ChangeFileNameKey.js","containers/Header.js","backend/yaas.js","containers/Editor.js","App.js","reducers/ToggleEditorProps.js","store.js","serviceWorker.js","index.js"],"names":["type","fileNameKey","tagFilters","id","x","Grammar","Lexer","undefined","ParserRules","name","symbols","postprocess","literal","pos","d","join","concat","ParserStart","parse","inputText","outputParsedExpr","parser","nearley","Parser","fromCompiled","feed","trim","results","length","ex","initialTagFiltersText","localStorage","getItem","initialTagFiltersExpr","parseTagFilters","filesListStr","filesList","Set","JSON","setItem","stringify","Array","from","Header","TAG_FILTERS_INPUT_ID","FILE_EXPLORER_INPUT_ID","FILE_EXPLORER_LIST_ID","FILE_NAME_KEY_CHAR_REGEX","state","tagFiltersText","handleApplyTagFilters","modifyState","checkState","tagFiltersInput","document","getElementById","value","tagFiltersExpr","setState","props","setTagFilters","text","expr","handleTagFiltersKeyPress","event","key","handleToggleEditorReadOnly","editorReadOnly","toggleEditorReadOnly","handleToggleEditorDarkMode","toggleEditorDarkMode","handleFileExplorerKeyPress","handleLoadFile","test","preventDefault","add","changeFileNameKey","handleRemoveFile","delete","removeItem","render","map","className","disabled","placeholder","defaultValue","onKeyPress","onClick","list","editorDarkMode","React","Component","connect","dispatch","Actions","SERVER_URL","docID","a","fetch","response","json","putDocument","documentJSON","method","body","headers","Headers","alert","Editor","defaultJSON","serverRunning","handleEditorChange","debounce","console","log","style","backgroundColor","readOnly","dark","onSave","options","toJSON","onChange","getDocument","then","data","catch","Home","color","bg","backgroundImage","heading","subhead","width","href","Edit","basename","exact","path","component","EDITOR_PROPS_LOCAL_STORAGE_KEYS","store","configureStore","reducer","combineReducers","action","subscribe","getState","Boolean","window","location","hostname","match","StrictMode","navigator","serviceWorker","ready","registration","unregister","error","message"],"mappings":"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","file":"static/js/main.ad64325b.chunk.js","sourcesContent":["export const TOGGLE_EDITOR_READ_ONLY = { type: 'TOGGLE_EDITOR_READ_ONLY' };\nexport const TOGGLE_EDITOR_DARK_MODE = { type: 'TOGGLE_EDITOR_DARK_MODE' };\n\nexport const CHANGE_FILE_NAME_KEY_TYPE = 'CHANGE_FILE_NAME_KEY';\nexport const changeFileNameKey = fileNameKey => ({ type: CHANGE_FILE_NAME_KEY_TYPE, fileNameKey });\n\nexport const SET_TAG_FILTERS_TYPE = 'SET_TAG_FILTERS';\nexport const setTagFilters = tagFilters => ({type: SET_TAG_FILTERS_TYPE, tagFilters});\n\nexport default {\n  'TOGGLE_EDITOR_READ_ONLY': TOGGLE_EDITOR_READ_ONLY,\n  'TOGGLE_EDITOR_DARK_MODE': TOGGLE_EDITOR_DARK_MODE,\n  'CHANGE_FILE_NAME_KEY_TYPE': CHANGE_FILE_NAME_KEY_TYPE,\n  'changeFileNameKey': changeFileNameKey,\n  'SET_TAG_FILTERS_TYPE': SET_TAG_FILTERS_TYPE,\n  'setTagFilters': setTagFilters,\n};\n","import nearley from 'nearley';\n// Generated automatically by nearley, version undefined\n// http://github.com/Hardmath123/nearley\n/*\nMain -> Expression {% id %}\nExpression -> Expression_ {% id %} | Factor {% id %}\nExpression_ -> Factor _ \"|\" _ Expression {% function(d) { return [d[0], d[2], d[4]] } %}\nFactor -> Factor_ {% id %} | Term {% id %}\nFactor_ -> Term _ \"&\" _ Factor {% function(d) { return [d[0], d[2], d[4]] } %}\nTerm -> Not {% id %} | Nested {% id %} | Tag {% id %}\nNot -> \"!\" (Nested {% id %} | Tag {% id %})\nNested -> \"(\" _ Expression _ \")\" {% function(d) { return d[2] } %}\nTag -> \"#{\" [^#{}]:+ \"}\" {% function(d) { return [d[0], d[1].join(\"\"), d[2]].join(\"\") } %}\n_ -> \" \":* {% function(d) { return null } %}\n*/\nfunction id(x) {\n  return x[0];\n}\nexport const Grammar = {\n  Lexer: undefined,\n  ParserRules: [\n    { name: \"Main\", symbols: [\"Expression\"], postprocess: id },\n    { name: \"Expression\", symbols: [\"Expression_\"], postprocess: id },\n    { name: \"Expression\", symbols: [\"Factor\"], postprocess: id },\n    {\n      name: \"Expression_\",\n      symbols: [\"Factor\", \"_\", { literal: \"|\", pos: 30 }, \"_\", \"Expression\"],\n      postprocess: function(d) {\n        return [d[0], d[2], d[4]];\n      },\n    },\n    { name: \"Factor\", symbols: [\"Factor_\"], postprocess: id },\n    { name: \"Factor\", symbols: [\"Term\"], postprocess: id },\n    {\n      name: \"Factor_\",\n      symbols: [\"Term\", \"_\", { literal: \"&\", pos: 60 }, \"_\", \"Factor\"],\n      postprocess: function(d) {\n        return [d[0], d[2], d[4]];\n      },\n    },\n    { name: \"Term\", symbols: [\"Not\"], postprocess: id },\n    { name: \"Term\", symbols: [\"Nested\"], postprocess: id },\n    { name: \"Term\", symbols: [\"Tag\"], postprocess: id },\n    { name: \"Not$subexpression$1\", symbols: [\"Nested\"], postprocess: id },\n    { name: \"Not$subexpression$1\", symbols: [\"Tag\"], postprocess: id },\n    {\n      name: \"Not\",\n      symbols: [{ literal: \"!\", pos: 92 }, \"Not$subexpression$1\"],\n    },\n    {\n      name: \"Nested\",\n      symbols: [\n        { literal: \"(\", pos: 110 },\n        \"_\",\n        \"Expression\",\n        \"_\",\n        { literal: \")\", pos: 118 },\n      ],\n      postprocess: function(d) {\n        return d[2];\n      },\n    },\n    {\n      name: \"Tag$string$1\",\n      symbols: [{ literal: \"#\" }, { literal: \"{\" }],\n      postprocess: function joiner(d) {\n        return d.join(\"\");\n      },\n    },\n    { name: \"Tag$ebnf$1\", symbols: [/[^#{}]/] },\n    {\n      name: \"Tag$ebnf$1\",\n      symbols: [/[^#{}]/, \"Tag$ebnf$1\"],\n      postprocess: function arrconcat(d) {\n        return [d[0]].concat(d[1]);\n      },\n    },\n    {\n      name: \"Tag\",\n      symbols: [\"Tag$string$1\", \"Tag$ebnf$1\", { literal: \"}\", pos: 131 }],\n      postprocess: function(d) {\n        return [d[0], d[1].join(\"\"), d[2]].join(\"\");\n      },\n    },\n    { name: \"_$ebnf$1\", symbols: [] },\n    {\n      name: \"_$ebnf$1\",\n      symbols: [{ literal: \" \", pos: 139 }, \"_$ebnf$1\"],\n      postprocess: function arrconcat(d) {\n        return [d[0]].concat(d[1]);\n      },\n    },\n    {\n      name: \"_\",\n      symbols: [\"_$ebnf$1\"],\n      postprocess: function(d) {\n        return null;\n      },\n    },\n  ],\n  ParserStart: \"Main\",\n};\nexport const parse = (inputText, throwErrors = true) => {\n  let outputParsedExpr = null;\n  if (inputText) {\n    const parser = new nearley.Parser(nearley.Grammar.fromCompiled(Grammar));\n    try {\n      parser.feed(inputText.trim());\n      if (parser.results.length > 0) {\n        outputParsedExpr = parser.results;\n      } else {\n        // TODO (incomplete)\n      }\n    } catch (ex) {\n      // TODO (invalid)\n    }\n  }\n  return outputParsedExpr;\n};\n","import Actions from '../actions';\nimport {parse as parseTagFilters} from '../lib/TagFilters';\n\nexport const INITIAL_TAG_FILTERS_LOCAL_STORAGE_KEY = 'initialTagFilters';\nexport const initialTagFiltersText =\n  localStorage.getItem(INITIAL_TAG_FILTERS_LOCAL_STORAGE_KEY) || '';\nexport const initialTagFiltersExpr = parseTagFilters(initialTagFiltersText);\n\nexport const SetTagFiltersReducer = (\n  state = { text: initialTagFiltersText, expr: initialTagFiltersExpr },\n  action,\n) => {\n  if (action.type !== Actions.SET_TAG_FILTERS_TYPE) return state;\n  return action.tagFilters;\n};\n","import Actions from '../actions';\n\nexport const FILE_NAME_PREFIX_LOCAL_STORAGE_KEY = 'file_';\nexport const INITIAL_FILE_NAME_LOCAL_STORAGE_KEY = 'initialFileName';\nexport const FILES_LIST_LOCAL_STORAGE_KEY = 'filesList';\n\nconst filesListStr = localStorage.getItem(FILES_LIST_LOCAL_STORAGE_KEY);\nconst filesList = new Set(filesListStr ? JSON.parse(filesListStr) : ['notes']);\nlocalStorage.setItem(FILES_LIST_LOCAL_STORAGE_KEY, JSON.stringify(Array.from(filesList)));\n\nexport const ChangeFileNameKeyReducer = (\n  state = localStorage.getItem(INITIAL_FILE_NAME_LOCAL_STORAGE_KEY) || 'notes',\n  action,\n) => {\n  if (action.type !== Actions.CHANGE_FILE_NAME_KEY_TYPE) return state;\n  return action.fileNameKey;\n};\n","import React from 'react';\nimport {connect} from 'react-redux';\nimport Actions from '../actions';\nimport {parse as parseTagFilters} from '../lib/TagFilters';\nimport {initialTagFiltersText} from \"../reducers/SetTagFilters\";\nimport {FILE_NAME_PREFIX_LOCAL_STORAGE_KEY, FILES_LIST_LOCAL_STORAGE_KEY} from '../reducers/ChangeFileNameKey';\n\nclass Header extends React.Component {\n  TAG_FILTERS_INPUT_ID = 'tag_filters_input';\n  FILE_EXPLORER_INPUT_ID = 'file_explorer_input';\n  FILE_EXPLORER_LIST_ID = 'file_explorer_list';\n  FILE_NAME_KEY_CHAR_REGEX = /\\w/;\n\n  state = {\n    tagFiltersText: initialTagFiltersText,\n  }\n\n  handleApplyTagFilters = (modifyState = true, checkState = true) => {\n    const tagFiltersInput = document.getElementById(this.TAG_FILTERS_INPUT_ID).value.trim();\n    if (checkState && tagFiltersInput === this.state.tagFiltersText) { return; } // don't need to re-apply\n    let tagFiltersExpr = null;\n    if (tagFiltersInput) {\n      tagFiltersExpr = parseTagFilters(tagFiltersInput);\n      if (!tagFiltersExpr) { // if invalid expr, reset the input value to the current valid tag filters text state\n        document.getElementById(this.TAG_FILTERS_INPUT_ID).value = this.state.tagFiltersText;\n        return;\n      }\n    }\n    if (modifyState) { this.setState({ tagFiltersText: tagFiltersInput }); }\n    this.props.setTagFilters({ text: tagFiltersInput, expr: tagFiltersExpr });\n  };\n\n  handleTagFiltersKeyPress = event => {\n    if (event.key === 'Enter') {\n      this.handleApplyTagFilters();\n    }\n  };\n\n  handleToggleEditorReadOnly = () => {\n    // currently the prop is the previous value, before toggling\n    document.getElementById(this.TAG_FILTERS_INPUT_ID).value =\n      this.props.editorReadOnly ? '' : this.state.tagFiltersText;\n    this.handleApplyTagFilters(false, false);\n    this.props.toggleEditorReadOnly();\n  };\n\n  handleToggleEditorDarkMode = () => this.props.toggleEditorDarkMode();\n\n  handleFileExplorerKeyPress = event => {\n    if (event.key === 'Enter') {\n      this.handleLoadFile();\n    }\n    if (event.key.length !== 1 || !this.FILE_NAME_KEY_CHAR_REGEX.test(event.key)) {\n      event.preventDefault();\n    }\n  };\n\n  handleLoadFile = () => {\n    const fileNameKey = document.getElementById(this.FILE_EXPLORER_INPUT_ID).value.trim();\n    if (fileNameKey) {\n      const filesListStr = localStorage.getItem(FILES_LIST_LOCAL_STORAGE_KEY);\n      localStorage.setItem(\n        FILES_LIST_LOCAL_STORAGE_KEY,\n        JSON.stringify(Array.from(new Set(filesListStr ? JSON.parse(filesListStr) : []).add(fileNameKey))),\n      );\n      this.props.changeFileNameKey(fileNameKey);\n      document.getElementById(this.TAG_FILTERS_INPUT_ID).value = '';\n      this.handleApplyTagFilters(true, false);\n    } else { // if doesn't exist, reset the input value to the currently open file\n      document.getElementById(this.FILE_EXPLORER_INPUT_ID).value = this.props.fileNameKey;\n    }\n  };\n\n  handleRemoveFile = () => {\n    const fileNameKey = document.getElementById(this.FILE_EXPLORER_INPUT_ID).value.trim();\n    if (fileNameKey === this.props.fileNameKey) {\n      return; // don't remove the currently open file\n    }\n    const filesListStr = localStorage.getItem(FILES_LIST_LOCAL_STORAGE_KEY);\n    const filesList = new Set(filesListStr ? JSON.parse(filesListStr) : []);\n    if (filesList.delete(fileNameKey)) {\n      localStorage.removeItem(FILE_NAME_PREFIX_LOCAL_STORAGE_KEY + fileNameKey);\n    }\n    localStorage.setItem(FILES_LIST_LOCAL_STORAGE_KEY, JSON.stringify(Array.from(filesList)));\n  }\n\n  render = () => {\n    const filesListStr = localStorage.getItem(FILES_LIST_LOCAL_STORAGE_KEY);\n    const filesList = (filesListStr ? JSON.parse(filesListStr) : [])\n      .map(fileNameKey => <option key={fileNameKey}>{fileNameKey}</option>);\n    return (\n      <div className=\"Header\">\n        <div className=\"SubHeader\">\n          <input\n            type=\"text\"\n            id={this.TAG_FILTERS_INPUT_ID}\n            disabled={!this.props.editorReadOnly}\n            placeholder={\n              this.props.editorReadOnly\n                ? 'TagFilters expr - e.g. \"#{tag1} | !(#{t 2} & !(#{_3}))\"'\n                : 'TagFilters are only enabled in ReadOnly mode'\n            }\n            defaultValue={this.props.editorReadOnly ? this.state.tagFiltersText : ''}\n            onKeyPress={this.handleTagFiltersKeyPress}\n          />\n          <button\n            type=\"button\"\n            disabled={!this.props.editorReadOnly}\n            onClick={this.handleApplyTagFilters}\n          >\n            Apply TagFilters\n          </button>\n        </div>\n        <div className=\"SubHeader\">\n          <input\n            type=\"text\"\n            id={this.FILE_EXPLORER_INPUT_ID}\n            list={this.FILE_EXPLORER_LIST_ID}\n            placeholder=\"file name/key\"\n            defaultValue={this.props.fileNameKey}\n            onKeyPress={this.handleFileExplorerKeyPress}\n          />\n          <datalist id={this.FILE_EXPLORER_LIST_ID}>{filesList}</datalist>\n          <button\n            type=\"button\"\n            onClick={this.handleLoadFile}\n          >\n            Load File\n          </button>\n          <button\n            type=\"button\"\n            onClick={this.handleRemoveFile}\n          >\n            Remove File\n          </button>\n        </div>\n        <div className=\"SubHeader\">\n          <button type=\"button\" onClick={this.handleToggleEditorDarkMode}>\n            {this.props.editorDarkMode ? 'Light' : 'Dark'} Theme\n          </button>\n          <button type=\"button\" onClick={this.handleToggleEditorReadOnly}>\n            Make {this.props.editorReadOnly ? 'Editable' : 'ReadOnly'}\n          </button>\n        </div>\n      </div>\n    );\n  };\n}\n\nexport default connect(\n  state => ({\n    editorDarkMode: state.editorDarkMode,\n    editorReadOnly: state.editorReadOnly,\n    fileNameKey: state.fileNameKey,\n  }),\n  dispatch => ({\n    toggleEditorDarkMode: () => dispatch(Actions.TOGGLE_EDITOR_DARK_MODE),\n    toggleEditorReadOnly: () => dispatch(Actions.TOGGLE_EDITOR_READ_ONLY),\n    changeFileNameKey: fileNameKey => dispatch(Actions.changeFileNameKey(fileNameKey)),\n    setTagFilters: tagFilters => dispatch(Actions.setTagFilters(tagFilters)),\n  }),\n)(Header);\n","import React from 'react';\n\nvar SERVER_URL = \"\"\nif (process.env.NODE_ENV == \"development\"){\n    SERVER_URL = \"http://localhost:5000/\";\n}else{\n    SERVER_URL = \"https://yaas.azurewebsites.net/\";\n}\n\nexport async function getDocument(docID) {\n\n    const response = await fetch(SERVER_URL + \"query?docID=\"+docID);\n    const json = await response.json();\n    return JSON.stringify(json);\n};\n\nexport async function putDocument(documentJSON, docID) {\n    const response = await fetch(SERVER_URL + \"document?docID=\"+docID, {\n        method: 'PUT',\n        body: JSON.stringify(documentJSON),\n        headers: new Headers({\n            'Content-Type': 'application/json'\n          })\n    });\n    alert(\"Document Saved Successfully\")\n}","import React from 'react';\nimport RichMarkdownEditor from 'rich-markdown-editor';\nimport {connect} from 'react-redux';\nimport {debounce} from 'lodash';\nimport {FILE_NAME_PREFIX_LOCAL_STORAGE_KEY} from '../reducers/ChangeFileNameKey';\nimport {getDocument, putDocument} from '../backend/yaas'\nclass Editor extends React.Component {\n\n  state = {\n    defaultJSON: null,\n    serverRunning: true\n  }\n\n  handleEditorChange = debounce(value => {\n    if (!this.props.editorReadOnly) {\n      localStorage.setItem(FILE_NAME_PREFIX_LOCAL_STORAGE_KEY + this.props.fileNameKey, value());\n    }\n  }, 250);\n\n  componentDidMount(){\n    getDocument(1).then(\n      data => this.setState({ defaultJSON: data })\n    ).catch (() => {\n      this.setState({ defaultJSON: \"\", serverRunning: false })\n    })\n  }\n  \n  render = () => {\n    if (this.state.defaultJSON == null){\n      return(<div>Loading...</div>)\n    }else{\n      console.log(\"Actual Editor\")\n      const {body} = document;\n      if (body) body.style.backgroundColor = this.props.editorDarkMode ? '#181A1B' : '#FFF';\n      if(this.state.serverRunning){\n        return (\n          <RichMarkdownEditor\n            readOnly={this.props.editorReadOnly}\n            dark={this.props.editorDarkMode}\n            key={this.props.fileNameKey}\n            defaultJSON = {this.state.defaultJSON}\n            tagFilters={this.props.tagFiltersExpr}\n            onSave={options => putDocument(options['doc'].toJSON(), 1)}\n          />\n        );\n      }else{\n        return (\n          <RichMarkdownEditor\n            readOnly={this.props.editorReadOnly}\n            dark={this.props.editorDarkMode}\n            key={this.props.fileNameKey}\n            defaultValue={localStorage.getItem(FILE_NAME_PREFIX_LOCAL_STORAGE_KEY + this.props.fileNameKey) || ''}\n            tagFilters={this.props.tagFiltersExpr}\n            onChange={this.handleEditorChange}\n          />\n        );\n      }\n    }\n  };\n}\n\nexport default connect(\n  state => ({\n    editorDarkMode: state.editorDarkMode,\n    editorReadOnly: state.editorReadOnly,\n    fileNameKey: state.fileNameKey,\n    tagFiltersExpr: state.tagFilters.expr,\n  }),\n)(Editor);\n","import React from 'react';\nimport './App.css';\nimport Header from './containers/Header';\nimport Editor from './containers/Editor.js';\nimport {\n    Hero, CallToAction, Section\n} from 'react-landing-page'\nimport { HashRouter, Route, Link } from \"react-router-dom\";\n\nimport GoogleLogin from \"react-google-login\";\n\nconst Home = () => {\n    return (<div>\n        <Hero\n            color=\"black\"\n            bg=\"white\"\n            backgroundImage=\"https://source.unsplash.com/npxXWgQ33ZQ/1600x900\"\n        >\n            <Section heading='YADA' subhead='Yet Another Docs App' width={1}>\n                <CallToAction href='#/edit'>Get Started</CallToAction>\n            </Section>\n        </Hero>\n    </div>);\n}\n\nconst Edit = () => {\n    return (<div className=\"App\">\n        <Header/>\n        <Editor/>\n    </div>);\n}\n\nexport default () => (\n    <HashRouter  basename=\"/yada\">\n        <div>\n            {/*LANDING PAGE*/}\n            <Route exact path=\"/\" component={Home} />\n            {/*CREATE / UPDATE / VIEW */}\n            <Route exact path=\"/edit\" component={Edit} />\n        </div>\n        <footer>&copy; 2020 FYDP-SAAC</footer>\n    </HashRouter>\n);\n","import Actions from '../actions';\n\nexport const EDITOR_PROPS_LOCAL_STORAGE_KEYS = {\n  EDITOR_READ_ONLY: 'editorReadOnly',\n  EDITOR_DARK_MODE: 'editorDarkMode',\n};\n\nexport const ToggleEditorReadOnlyReducer = (\n  state = localStorage.getItem(EDITOR_PROPS_LOCAL_STORAGE_KEYS.EDITOR_READ_ONLY) === 'ReadOnly',\n  action,\n) => {\n  if (action.type === Actions.TOGGLE_EDITOR_READ_ONLY.type) return !state;\n  return state;\n};\n\nexport const ToggleEditorDarkModeReducer = (\n  state = localStorage.getItem(EDITOR_PROPS_LOCAL_STORAGE_KEYS.EDITOR_DARK_MODE) === 'Dark',\n  action,\n) => {\n  if (action.type === Actions.TOGGLE_EDITOR_DARK_MODE.type) return !state;\n  return state;\n};\n","import {configureStore} from '@reduxjs/toolkit';\nimport {combineReducers} from 'redux';\nimport {EDITOR_PROPS_LOCAL_STORAGE_KEYS, ToggleEditorDarkModeReducer, ToggleEditorReadOnlyReducer} from './reducers/ToggleEditorProps';\nimport {INITIAL_FILE_NAME_LOCAL_STORAGE_KEY, ChangeFileNameKeyReducer} from './reducers/ChangeFileNameKey';\nimport {INITIAL_TAG_FILTERS_LOCAL_STORAGE_KEY, SetTagFiltersReducer} from './reducers/SetTagFilters';\n\nconst store = configureStore({\n  reducer: combineReducers({\n    editorDarkMode: ToggleEditorDarkModeReducer,\n    editorReadOnly: ToggleEditorReadOnlyReducer,\n    fileNameKey: ChangeFileNameKeyReducer,\n    tagFilters: SetTagFiltersReducer,\n  }),\n});\n\nstore.subscribe(() => {\n  localStorage.setItem(\n    EDITOR_PROPS_LOCAL_STORAGE_KEYS.EDITOR_DARK_MODE,\n    store.getState().editorDarkMode ? 'Dark' : 'Light',\n  );\n  localStorage.setItem(\n    EDITOR_PROPS_LOCAL_STORAGE_KEYS.EDITOR_READ_ONLY,\n    store.getState().editorReadOnly ? 'ReadOnly' : 'Editable',\n  );\n  localStorage.setItem(INITIAL_FILE_NAME_LOCAL_STORAGE_KEY, store.getState().fileNameKey);\n  localStorage.setItem(\n    INITIAL_TAG_FILTERS_LOCAL_STORAGE_KEY,\n    store.getState().tagFilters.text || '',\n  );\n});\n\nexport default store;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.0/8 are considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: {'Service-Worker': 'script'},\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport {render} from 'react-dom';\nimport {Provider} from 'react-redux';\nimport './index.css';\nimport App from './App';\nimport store from './store';\nimport * as serviceWorker from './serviceWorker';\n\nrender(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App/>\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}