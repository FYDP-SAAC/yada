{"version":3,"sources":["containers/TagFiltersTextGrammar.js","actions/index.js","reducers/ToggleEditorProps.js","containers/Header.js","containers/Editor.js","App.js","store.js","serviceWorker.js","index.js"],"names":["Lexer","undefined","ParserRules","d","join","concat","ParserStart","type","PROPS_LOCAL_STORAGE_KEYS","Header","FILTERS_LOCAL_STORAGE_KEY","TAG_FILTERS_INPUT_ID","TAG_FILTERS_BUTTON_ID","state","tagFiltersDirty","tagFiltersText","localStorage","getItem","tagFiltersExpr","handleApplyTagFilters","props","editorReadOnly","parser","nearley","Parser","Grammar","fromCompiled","TagFiltersTextGrammar","feed","trim","ex","results","length","setItem","setState","handleTagFiltersChange","document","getElementById","value","handleTagFiltersEnter","event","key","handleToggleEditorReadOnly","toggleEditorReadOnly","handleToggleEditorDarkMode","toggleEditorDarkMode","editorDarkMode","render","className","onClick","id","disabled","placeholder","defaultValue","onKeyPress","onChange","React","Component","connect","dispatch","Actions","Editor","LOCAL_STORAGE_KEY","handleEditorChange","debounce","body","style","backgroundColor","this","readOnly","dark","configureStore","reducer","combineReducers","action","Boolean","window","location","hostname","match","StrictMode","store","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.62267f14.chunk.js","sourcesContent":["// Generated automatically by nearley, version undefined\n// http://github.com/Hardmath123/nearley\nexport default {\n  Lexer: undefined,\n  ParserRules: [\n    {\"name\": \"Main\", \"symbols\": [\"Expr\"]},\n    {\"name\": \"Main\", \"symbols\": []},\n    {\"name\": \"Expr\", \"symbols\": [\"Or\"]},\n    {\"name\": \"Expr\", \"symbols\": [\"And_\"]},\n    {\"name\": \"Or\", \"symbols\": [\"Expr\", \"__\", {\"literal\": \"|\", \"pos\": 28}, \"__\", \"And_\"]},\n    {\"name\": \"And_\", \"symbols\": [\"And\"]},\n    {\"name\": \"And_\", \"symbols\": [\"Term_\"]},\n    {\"name\": \"And\", \"symbols\": [\"And_\", \"__\", {\"literal\": \"&\", \"pos\": 52}, \"__\", \"Term_\"]},\n    {\"name\": \"Term_\", \"symbols\": [\"Not\"]},\n    {\"name\": \"Term_\", \"symbols\": [\"Expr_\"]},\n    {\"name\": \"Term_\", \"symbols\": [\"Term\"]},\n    {\"name\": \"Not\", \"symbols\": [{\"literal\": \"!\", \"pos\": 76}, \"Expr_\"]},\n    {\"name\": \"Expr_\", \"symbols\": [{\"literal\": \"(\", \"pos\": 84}, \"_\", \"Expr\", \"_\", {\"literal\": \")\", \"pos\": 92}]},\n    {\n      \"name\": \"Term$string$1\", \"symbols\": [{\"literal\": \"#\"}, {\"literal\": \"{\"}], \"postprocess\": function joiner(d) {\n        return d.join('');\n      }\n    },\n    {\"name\": \"Term\", \"symbols\": [\"Term$string$1\", \"n\", {\"literal\": \"}\", \"pos\": 102}]},\n    {\"name\": \"n$ebnf$1\", \"symbols\": [/[^{}]/]},\n    {\n      \"name\": \"n$ebnf$1\", \"symbols\": [/[^{}]/, \"n$ebnf$1\"], \"postprocess\": function arrconcat(d) {\n        return [d[0]].concat(d[1]);\n      }\n    },\n    {\"name\": \"n\", \"symbols\": [\"n$ebnf$1\"]},\n    {\"name\": \"__$ebnf$1\", \"symbols\": [{\"literal\": \" \", \"pos\": 115}]},\n    {\n      \"name\": \"__$ebnf$1\",\n      \"symbols\": [{\"literal\": \" \", \"pos\": 115}, \"__$ebnf$1\"],\n      \"postprocess\": function arrconcat(d) {\n        return [d[0]].concat(d[1]);\n      }\n    },\n    {\"name\": \"__\", \"symbols\": [\"__$ebnf$1\"]},\n    {\"name\": \"_$ebnf$1\", \"symbols\": []},\n    {\n      \"name\": \"_$ebnf$1\", \"symbols\": [{\"literal\": \" \", \"pos\": 122}, \"_$ebnf$1\"], \"postprocess\": function arrconcat(d) {\n        return [d[0]].concat(d[1]);\n      }\n    },\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"]}\n  ]\n  , ParserStart: \"Main\"\n};\n","export const TOGGLE_EDITOR_READ_ONLY = {\n  type: 'TOGGLE_EDITOR_READ_ONLY',\n};\n\nexport const TOGGLE_EDITOR_DARK_MODE = {\n  type: 'TOGGLE_EDITOR_DARK_MODE',\n};\n\nexport default {\n  'TOGGLE_EDITOR_READ_ONLY': TOGGLE_EDITOR_READ_ONLY,\n  'TOGGLE_EDITOR_DARK_MODE': TOGGLE_EDITOR_DARK_MODE,\n}\n","import Actions from '../actions';\n\nexport const PROPS_LOCAL_STORAGE_KEYS = {\n  EDITOR_READ_ONLY: \"editorReadOnly\",\n  EDITOR_DARK_MODE: \"editorDarkMode\",\n};\n\nexport const ToggleEditorReadOnlyReducer = (\n  state = localStorage.getItem(PROPS_LOCAL_STORAGE_KEYS.EDITOR_READ_ONLY) === 'ReadOnly',\n  action,\n) => {\n  if (action.type === Actions.TOGGLE_EDITOR_READ_ONLY.type) return !state;\n  return state;\n};\n\nexport const ToggleEditorDarkModeReducer = (\n  state = localStorage.getItem(PROPS_LOCAL_STORAGE_KEYS.EDITOR_DARK_MODE) === 'Dark',\n  action,\n) => {\n  if (action.type === Actions.TOGGLE_EDITOR_DARK_MODE.type) return !state;\n  return state;\n};\n","import React from 'react';\nimport {connect} from 'react-redux';\nimport nearley from 'nearley'\nimport TagFiltersTextGrammar from './TagFiltersTextGrammar'\nimport Actions from '../actions';\nimport {PROPS_LOCAL_STORAGE_KEYS} from '../reducers/ToggleEditorProps';\n\nclass Header extends React.Component {\n  FILTERS_LOCAL_STORAGE_KEY = 'filters';\n  TAG_FILTERS_INPUT_ID = 'tag_filters_input';\n  TAG_FILTERS_BUTTON_ID = 'tag_filters_button';\n\n  state = {\n    tagFiltersDirty: true,\n    tagFiltersText: localStorage.getItem(this.FILTERS_LOCAL_STORAGE_KEY) || '',\n    tagFiltersExpr: undefined,\n  };\n\n  handleApplyTagFilters = () => {\n    if (this.props.editorReadOnly) { // sanity check\n      if (this.state.tagFiltersDirty) {\n        const parser = new nearley.Parser(nearley.Grammar.fromCompiled(TagFiltersTextGrammar));\n        try {\n          parser.feed(this.state.tagFiltersText.trim());\n        } catch(ex) {\n          // invalid\n          return;\n        }\n        const parsed = parser.results;\n        if (parsed.length === 0) {\n          // incomplete\n          return;\n        }\n        localStorage.setItem(this.FILTERS_LOCAL_STORAGE_KEY, this.state.tagFiltersText);\n        this.setState({tagFiltersDirty: false, tagFiltersExpr: parser.results});\n      }\n      // TODO pass tagFiltersExpr value to editor somehow (via redux?)\n    }\n  };\n\n  // is there a race condition with the following two methods that would cause the disabled text value to be saved?\n  handleTagFiltersChange = () => {\n    if (this.props.editorReadOnly) {\n      this.setState({\n        tagFiltersDirty: true,\n        tagFiltersText: document.getElementById(this.TAG_FILTERS_INPUT_ID).value,\n      });\n    }\n  };\n\n  handleTagFiltersEnter = event => {\n    if (event.key === 'Enter') {\n      this.handleApplyTagFilters();\n    }\n  }\n\n  handleToggleEditorReadOnly = () => {\n    this.props.toggleEditorReadOnly();\n    // dispatch is async? so state/prop change only happens once function exits? so the prop is the previous value.\n    localStorage.setItem(PROPS_LOCAL_STORAGE_KEYS.EDITOR_READ_ONLY,\n      this.props.editorReadOnly ? 'Editable' : 'ReadOnly');\n    document.getElementById(this.TAG_FILTERS_INPUT_ID).value =\n      this.props.editorReadOnly ? '' : this.state.tagFiltersText;\n  };\n\n  handleToggleEditorDarkMode = () => {\n    this.props.toggleEditorDarkMode();\n    // dispatch is async? so state/prop change only happens once function exits? so the prop is the previous value.\n    localStorage.setItem(PROPS_LOCAL_STORAGE_KEYS.EDITOR_DARK_MODE,\n      this.props.editorDarkMode ? 'Light' : 'Dark');\n  };\n\n  render = () => (\n    <div className=\"Header\">\n      <button type=\"button\" onClick={this.handleToggleEditorDarkMode}>\n        {this.props.editorDarkMode ? 'Light' : 'Dark'} Theme\n      </button>\n      <button type=\"button\" onClick={this.handleToggleEditorReadOnly}>\n        Make {this.props.editorReadOnly ? 'Editable' : 'ReadOnly'}\n      </button>\n      <button\n        type=\"button\"\n        id={this.TAG_FILTERS_BUTTON_ID}\n        disabled={!this.props.editorReadOnly}\n        onClick={this.handleApplyTagFilters}\n      >\n        Apply TagFilters\n      </button>\n      <input\n        type=\"text\"\n        id={this.TAG_FILTERS_INPUT_ID}\n        disabled={!this.props.editorReadOnly}\n        placeholder={\n          this.props.editorReadOnly ?\n            'TagFilters expr - e.g. \"#{tag1} | !(#{t2} & !(#{_3}))\"' : 'TagFilters are only enabled in ReadOnly mode'\n        }\n        defaultValue={this.props.editorReadOnly ? this.state.tagFiltersText : ''}\n        onKeyPress={this.handleTagFiltersEnter}\n        onChange={this.handleTagFiltersChange}\n      />\n    </div>\n  );\n}\n\nexport default connect(\n  state => ({editorDarkMode: state.editorDarkMode, editorReadOnly: state.editorReadOnly}),\n  dispatch => ({\n    toggleEditorDarkMode: () => dispatch(Actions.TOGGLE_EDITOR_DARK_MODE),\n    toggleEditorReadOnly: () => dispatch(Actions.TOGGLE_EDITOR_READ_ONLY),\n  }),\n)(Header);\n","import React from \"react\";\nimport RichMarkdownEditor from 'rich-markdown-editor';\nimport {connect} from 'react-redux';\nimport {debounce} from 'lodash';\n\nclass Editor extends React.Component {\n  LOCAL_STORAGE_KEY = 'saved';\n\n  handleEditorChange = debounce(value => {\n    if (!this.props.editorReadOnly) {\n      localStorage.setItem(this.LOCAL_STORAGE_KEY, value());\n    }\n  }, 250);\n\n  render() {\n    const {body} = document;\n    if (body) body.style.backgroundColor = this.props.editorDarkMode ? \"#181A1B\" : \"#FFF\";\n    return (\n      <RichMarkdownEditor\n        readOnly={this.props.editorReadOnly}\n        dark={this.props.editorDarkMode}\n        defaultValue={localStorage.getItem(this.LOCAL_STORAGE_KEY) || ''}\n        onChange={this.handleEditorChange}\n      />\n    );\n  };\n}\n\nexport default connect(state => ({editorDarkMode: state.editorDarkMode, editorReadOnly: state.editorReadOnly}))(Editor);\n","import React from 'react';\nimport './App.css';\nimport Header from './containers/Header';\nimport Editor from './containers/Editor.js';\n\nexport default () => (\n  <div>\n    <div className=\"App\">\n      <Header/>\n      <Editor/>\n    </div>\n    <footer>&copy; 2020 Carl Shen (ca-shen98)</footer>\n  </div>\n);\n","import {configureStore} from '@reduxjs/toolkit';\nimport {combineReducers} from 'redux';\nimport {ToggleEditorDarkModeReducer, ToggleEditorReadOnlyReducer} from './reducers/ToggleEditorProps';\n\nexport default configureStore({\n  reducer: combineReducers({\n    editorDarkMode: ToggleEditorDarkModeReducer,\n    editorReadOnly: ToggleEditorReadOnlyReducer,\n  }),\n});\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.0/8 are considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: {'Service-Worker': 'script'},\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport {render} from 'react-dom';\nimport {Provider} from 'react-redux';\nimport './index.css';\nimport App from './App';\nimport store from './store';\nimport * as serviceWorker from './serviceWorker';\n\n// const store = createStore(rootReducer);\n\nrender(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App/>\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}