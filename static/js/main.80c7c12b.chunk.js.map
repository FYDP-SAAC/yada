{"version":3,"sources":["containers/TagFiltersTextGrammar.js","actions/index.js","containers/Header.js","reducers/ToggleEditorReadOnly.js","containers/Editor.js","App.js","store.js","serviceWorker.js","index.js"],"names":["Lexer","undefined","ParserRules","d","join","concat","ParserStart","TOGGLE_EDITOR_READ_ONLY","type","Header","FILTERS_LOCAL_STORAGE_KEY","TAG_FILTERS_INPUT_ID","TAG_FILTERS_BUTTON_ID","state","tagFiltersDirty","tagFiltersText","localStorage","getItem","tagFiltersExpr","handleApplyTagFilters","props","editorReadOnly","parser","nearley","Parser","Grammar","fromCompiled","TagFiltersTextGrammar","feed","trim","ex","results","length","setItem","setState","handleTagFiltersChange","document","getElementById","value","handleTagFiltersEnter","event","key","handleToggleEditorReadOnly","toggleEditorReadOnly","render","className","onClick","id","disabled","placeholder","defaultValue","onKeyPress","onChange","React","Component","connect","dispatch","Editor","LOCAL_STORAGE_KEY","handleEditorChange","debounce","readOnly","configureStore","reducer","combineReducers","action","Boolean","window","location","hostname","match","StrictMode","store","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.80c7c12b.chunk.js","sourcesContent":["// Generated automatically by nearley, version undefined\n// http://github.com/Hardmath123/nearley\nexport default {\n  Lexer: undefined,\n  ParserRules: [\n    {\"name\": \"Main\", \"symbols\": [\"Expr\"]},\n    {\"name\": \"Main\", \"symbols\": []},\n    {\"name\": \"Expr\", \"symbols\": [\"Or\"]},\n    {\"name\": \"Expr\", \"symbols\": [\"And_\"]},\n    {\"name\": \"Or\", \"symbols\": [\"Expr\", \"__\", {\"literal\": \"|\", \"pos\": 28}, \"__\", \"And_\"]},\n    {\"name\": \"And_\", \"symbols\": [\"And\"]},\n    {\"name\": \"And_\", \"symbols\": [\"Term_\"]},\n    {\"name\": \"And\", \"symbols\": [\"And_\", \"__\", {\"literal\": \"&\", \"pos\": 52}, \"__\", \"Term_\"]},\n    {\"name\": \"Term_\", \"symbols\": [\"Not\"]},\n    {\"name\": \"Term_\", \"symbols\": [\"Expr_\"]},\n    {\"name\": \"Term_\", \"symbols\": [\"Term\"]},\n    {\"name\": \"Not\", \"symbols\": [{\"literal\": \"!\", \"pos\": 76}, \"Expr_\"]},\n    {\"name\": \"Expr_\", \"symbols\": [{\"literal\": \"(\", \"pos\": 84}, \"_\", \"Expr\", \"_\", {\"literal\": \")\", \"pos\": 92}]},\n    {\n      \"name\": \"Term$string$1\", \"symbols\": [{\"literal\": \"#\"}, {\"literal\": \"{\"}], \"postprocess\": function joiner(d) {\n        return d.join('');\n      }\n    },\n    {\"name\": \"Term\", \"symbols\": [\"Term$string$1\", \"n\", {\"literal\": \"}\", \"pos\": 102}]},\n    {\"name\": \"n$ebnf$1\", \"symbols\": [/[^{}]/]},\n    {\n      \"name\": \"n$ebnf$1\", \"symbols\": [/[^{}]/, \"n$ebnf$1\"], \"postprocess\": function arrconcat(d) {\n        return [d[0]].concat(d[1]);\n      }\n    },\n    {\"name\": \"n\", \"symbols\": [\"n$ebnf$1\"]},\n    {\"name\": \"__$ebnf$1\", \"symbols\": [{\"literal\": \" \", \"pos\": 115}]},\n    {\n      \"name\": \"__$ebnf$1\",\n      \"symbols\": [{\"literal\": \" \", \"pos\": 115}, \"__$ebnf$1\"],\n      \"postprocess\": function arrconcat(d) {\n        return [d[0]].concat(d[1]);\n      }\n    },\n    {\"name\": \"__\", \"symbols\": [\"__$ebnf$1\"]},\n    {\"name\": \"_$ebnf$1\", \"symbols\": []},\n    {\n      \"name\": \"_$ebnf$1\", \"symbols\": [{\"literal\": \" \", \"pos\": 122}, \"_$ebnf$1\"], \"postprocess\": function arrconcat(d) {\n        return [d[0]].concat(d[1]);\n      }\n    },\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"]}\n  ]\n  , ParserStart: \"Main\"\n};\n","export const TOGGLE_EDITOR_READ_ONLY = {\n  type: 'TOGGLE_EDITOR_READ_ONLY',\n};\n","import React from 'react';\nimport {connect} from 'react-redux';\nimport nearley from 'nearley'\nimport TagFiltersTextGrammar from './TagFiltersTextGrammar'\nimport {TOGGLE_EDITOR_READ_ONLY} from '../actions';\nimport {MODE_LOCAL_STORAGE_KEY} from '../reducers/ToggleEditorReadOnly';\n\nclass Header extends React.Component {\n  FILTERS_LOCAL_STORAGE_KEY = 'filters';\n  TAG_FILTERS_INPUT_ID = 'tag_filters_input';\n  TAG_FILTERS_BUTTON_ID = 'tag_filters_button';\n\n  state = {\n    tagFiltersDirty: true,\n    tagFiltersText: localStorage.getItem(this.FILTERS_LOCAL_STORAGE_KEY) || '',\n    tagFiltersExpr: undefined,\n  };\n\n  handleApplyTagFilters = () => {\n    if (this.props.editorReadOnly) { // sanity check\n      if (this.state.tagFiltersDirty) {\n        const parser = new nearley.Parser(nearley.Grammar.fromCompiled(TagFiltersTextGrammar));\n        try {\n          parser.feed(this.state.tagFiltersText.trim());\n        } catch(ex) {\n          // invalid\n          return;\n        }\n        const parsed = parser.results;\n        if (parsed.length === 0) {\n          // incomplete\n          return;\n        }\n        localStorage.setItem(this.FILTERS_LOCAL_STORAGE_KEY, this.state.tagFiltersText);\n        this.setState({tagFiltersDirty: false, tagFiltersExpr: parser.results});\n      }\n      // TODO pass tagFiltersExpr value to editor somehow (via redux?)\n    }\n  };\n\n  // is there a race condition with the following two methods that would cause the disabled text value to be saved?\n  handleTagFiltersChange = () => {\n    if (this.props.editorReadOnly) {\n      this.setState({\n        tagFiltersDirty: true,\n        tagFiltersText: document.getElementById(this.TAG_FILTERS_INPUT_ID).value,\n      });\n    }\n  };\n\n  handleTagFiltersEnter = event => {\n    if (event.key === 'Enter') {\n      this.handleApplyTagFilters();\n    }\n  }\n\n  handleToggleEditorReadOnly = () => {\n    this.props.toggleEditorReadOnly();\n    // dispatch is async? so state/prop change only happens once function exits? so the prop is the previous value.\n    localStorage.setItem(MODE_LOCAL_STORAGE_KEY, this.props.editorReadOnly ? 'Editable' : 'ReadOnly');\n    document.getElementById(this.TAG_FILTERS_INPUT_ID).value =\n      this.props.editorReadOnly ? '' : this.state.tagFiltersText;\n  };\n\n  render = () => (\n    <div className=\"Header\">\n      <button type=\"button\" onClick={this.handleToggleEditorReadOnly}>\n        Make {this.props.editorReadOnly ? 'Editable' : 'ReadOnly'}\n      </button>\n      <button\n        type=\"button\"\n        id={this.TAG_FILTERS_BUTTON_ID}\n        disabled={!this.props.editorReadOnly}\n        onClick={this.handleApplyTagFilters}\n      >\n        Apply TagFilters\n      </button>\n      <input\n        type=\"text\"\n        id={this.TAG_FILTERS_INPUT_ID}\n        disabled={!this.props.editorReadOnly}\n        placeholder={\n          this.props.editorReadOnly ?\n            'TagFilters expr - e.g. \"#{tag1} | !(#{t2} & !(#{_3}))\"' : 'TagFilters are only enabled in ReadOnly mode'\n        }\n        defaultValue={this.props.editorReadOnly ? this.state.tagFiltersText : ''}\n        onKeyPress={this.handleTagFiltersEnter}\n        onChange={this.handleTagFiltersChange}\n      />\n    </div>\n  );\n}\n\nexport default connect(\n  state => ({editorReadOnly: state.editorReadOnly}),\n  dispatch => ({\n    toggleEditorReadOnly: () => dispatch(TOGGLE_EDITOR_READ_ONLY),\n  }),\n)(Header);\n","import {TOGGLE_EDITOR_READ_ONLY} from '../actions';\n\nexport const MODE_LOCAL_STORAGE_KEY = \"mode\";\n\nexport default (state = localStorage.getItem(MODE_LOCAL_STORAGE_KEY) === 'ReadOnly', action) => {\n  if (action.type === TOGGLE_EDITOR_READ_ONLY.type) return !state;\n  return state;\n};\n","import React from \"react\";\nimport RichMarkdownEditor from 'rich-markdown-editor';\nimport {connect} from 'react-redux';\nimport {debounce} from 'lodash';\n\nclass Editor extends React.Component {\n  LOCAL_STORAGE_KEY = 'saved';\n\n  handleEditorChange = debounce(value => {\n    if (!this.props.editorReadOnly) {\n      localStorage.setItem(this.LOCAL_STORAGE_KEY, value());\n    }\n  }, 250);\n\n  render = () => (\n    <RichMarkdownEditor\n      readOnly={this.props.editorReadOnly}\n      defaultValue={localStorage.getItem(this.LOCAL_STORAGE_KEY) || ''}\n      onChange={this.handleEditorChange}\n    />\n  );\n}\n\nexport default connect(state => ({editorReadOnly: state.editorReadOnly}))(Editor);\n","import React from 'react';\nimport './App.css';\nimport Header from './containers/Header';\nimport Editor from './containers/Editor.js';\n\nexport default () => (\n  <div className=\"App\">\n    <Header/>\n    <Editor/>\n  </div>\n);\n","import {configureStore} from '@reduxjs/toolkit';\nimport {combineReducers} from 'redux';\nimport toggleEditorReadOnlyReducer from './reducers/ToggleEditorReadOnly';\n\nexport default configureStore({\n  reducer: combineReducers({editorReadOnly: toggleEditorReadOnlyReducer}),\n});\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.0/8 are considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: {'Service-Worker': 'script'},\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport {render} from 'react-dom';\nimport {Provider} from 'react-redux';\nimport './index.css';\nimport App from './App';\nimport store from './store';\nimport * as serviceWorker from './serviceWorker';\n\n// const store = createStore(rootReducer);\n\nrender(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App/>\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}